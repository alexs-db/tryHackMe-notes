# Understanding HTTP Request Structure

Every HTTP request comprises two main parts: the header and the body.

## HTTP Structure

### Request Line
The first line of the request `POST /admin/login HTTP/1.1` is the request line. It consists of at least three items:
- **Method**: In this case, "POST". The method is a one-word command that tells the server what to do with the resource.
- **Path**: The path component of the URL for the request, which in this case is `/admin/login`. The path identifies the resource on the server.
- **HTTP Version**: The HTTP version number shows the HTTP specification to which the client has tried to make the message comply. Note that HTTP/2 and HTTP/1.1 have different structures.

### Request Headers
This section contains metadata about the request, such as the type of content being sent, the desired response format, and authentication tokens. It's like the envelope of a letter, providing information about the sender, receiver, and the nature of the content inside.

### Message Body
This is the actual content of the request. The body might be empty for a GET request, but for a POST request, it could contain form data, JSON payloads, or file uploads.

## Content-Length Header

The `Content-Length` header indicates the request or response body size in bytes. It informs the receiving server how much data to expect, ensuring the entire content is received.

### Content-Length Sample Request
```
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 14

q=smuggledData
```
This means that the request or response body contains 14 bytes of data.

## Transfer-Encoding Header

The `Transfer-Encoding` header is used to specify the form of encoding applied to the message body of an HTTP request or response. A commonly used value for this header is `chunked`, indicating that the message body is divided into a series of chunks, each preceded by its size in hexadecimal format. Other possible values for the `Transfer-Encoding` header include `compress`, `deflate`, and `gzip`, each indicating a different type of encoding.

### Transfer-Encoding Sample Request
```
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

b
q=smuggledData
0
```
In this example, `b` (in hexadecimal, equivalent to 11 in decimal) specifies the size of the following chunk. The chunk `q=smuggledData` is the actual data, followed by a new line. The request is terminated with a `0` line, indicating the end of the message body. Each chunk size is given in hexadecimal format, and the end of the chunked body is signified by a chunk of size 0.

## How Headers Affect Request Processing

Headers play an important role in guiding the server to process the request. They determine how to parse the request body and influence caching behaviours. They can also affect authentication, redirection, and other server responses.

### How Headers Affect Request Process

Manipulating headers like `Content-Length` and `Transfer-Encoding` can create vulnerabilities. For instance, if a proxy server gets confused by these headers, it might not properly distinguish where one request ends and another starts.

## HTTP Request Smuggling Origin

HTTP Request Smuggling primarily occurs due to discrepancies in how different servers (like a front-end server and a back-end server) interpret HTTP request boundaries. For example:
- If both `Content-Length` and `Transfer-Encoding` headers are present, ambiguities can arise.
- Some components prioritize `Content-Length`, while others prioritize `Transfer-Encoding`.

This discrepancy can lead to one component believing the request has ended while another thinks it's still ongoing, leading to smuggling.

### Example
Suppose a front-end server uses the `Content-Length` header to determine the end of a request while a back-end server uses the `Transfer-Encoding` header. An attacker can craft a request that appears to have one boundary to the front-end server but a different boundary to the back-end server. This can lead to one request being "smuggled" inside another, causing unexpected behaviour and potential vulnerabilities.