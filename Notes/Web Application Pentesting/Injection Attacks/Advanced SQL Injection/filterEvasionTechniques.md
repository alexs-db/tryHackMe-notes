In advanced SQL injection attacks, evading filters is crucial for successfully exploiting vulnerabilities. Modern web applications often implement defensive measures to sanitise or block common attack patterns, making simple SQL injection attempts ineffective. As pentesters, we must adapt using more sophisticated techniques to bypass these filters. This section will cover such methods, including character encoding, no-quote SQL injection, and handling scenarios where spaces cannot be used. We can effectively penetrate web applications with stringent input validation and security controls by understanding and applying these techniques. list of keywords for filter evasion

Character Encoding
Character encoding involves converting special characters in the SQL injection payload into encoded forms that may bypass input filters.

URL Encoding: URL encoding is a common method where characters are represented using a percent (%) sign followed by their ASCII value in hexadecimal. For example, the payload ' OR 1=1-- can be encoded as %27%20OR%201%3D1--. This encoding can help the input pass through web application filters and be decoded by the database, which might not recognise it as malicious during initial processing.
Hexadecimal Encoding: Hexadecimal encoding is another effective technique for constructing SQL queries using hexadecimal values. For instance, the query SELECT * FROM users WHERE name = 'admin' can be encoded as SELECT * FROM users WHERE name = 0x61646d696e. By representing characters as hexadecimal numbers, the attacker can bypass filters that do not decode these values before processing the input.
Unicode Encoding: Unicode encoding represents characters using Unicode escape sequences. For example, the string admin can be encoded as \u0061\u0064\u006d\u0069\u006e. This method can bypass filters that only check for specific ASCII characters, as the database will correctly process the encoded input.
Example

In this example, we explore how developers can implement basic filtering to prevent SQL injection attacks by removing specific keywords and characters from user input. However, we will also see how attackers can bypass these defences using character encoding techniques like URL encoding.

Note: In the upcoming exercises, we will use databases that are different from the last ones. You can access the page at http://10.10.171.77/encoding/.

Here's the PHP code (search_books.php) that handles the search functionality:


$book_name = $_GET['book_name'] ?? '';
$special_chars = array("OR", "or", "AND", "and" , "UNION", "SELECT");
$book_name = str_replace($special_chars, '', $book_name);
$sql = "SELECT * FROM books WHERE book_name = '$book_name'";
echo "<p>Generated SQL Query: $sql</p>";
$result = $conn->query($sql) or die("Error: " . $conn->error . " (Error Code: " . $conn->errno . ")");
if ($result->num_rows > 0) {
    while ($row = $result->fetch_assoc()) {
...
..
Here's the Javascript code in the index.html page that provides the user interface for searching books:


function searchBooks() {
const bookName = document.getElementById('book_name').value;
const xhr = new XMLHttpRequest();
xhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);
   xhr.onload = function() {
       if (this.status === 200) {
           document.getElementById('results').innerHTML = this.responseText;
In the above example, the developer has implemented a basic defence mechanism to prevent SQL injection attacks by removing specific SQL keywords, such as OR, AND, UNION, and SELECT. The filtering uses the str_replace function, which strips these keywords from the user input before they are included in the SQL query. This filtering approach aims to make it harder for attackers to inject malicious SQL commands, as these keywords are essential for many SQL injection payloads.

Preparing the Payload

Let's go through the process of preparing an SQL injection payload step-by-step, showing how URL encoding can bypass basic defences. First, letâ€™s see what happens with a normal input that contains special characters or SQL keywords. When we search for a book named Intro to PHP, we get the successful result as shown below:

search for a book dashboard

But what if we try to break the query by adding special characters like ', ;, etc? We will get the following output:

error result while searching a book

The SQL query is not executing correctly, which probably means there is a chance of SQL Injection. Let's try to inject the payload "Intro to PHP' OR 1=1". We will get the following output:

error result with injection payload

So, what is happening here? When this input is passed to the PHP script, the str_replace function will strip out the OR keyword and the single quote, resulting in a sanitised input that will not execute the intended SQL injection. This input is ineffective because the filtering removes the critical components needed for the SQL injection to succeed.

To bypass the filtering, we need to encode the input using URL encoding, which represents special characters and keywords in a way that the filter does not recognise and remove. Here is the example payload 1%27%20||%201=1%20--+.

%27 is the URL encoding for the single quote (').
%20 is the URL encoding for a space ( ).
|| represents the SQL OR operator.
%3D is the URL encoding for the equals sign (=).
%2D%2D is the URL encoding for --, which starts a comment in SQL.
In the above payload, 1' closes the current string or value in the SQL query. For example, if the query is looking for a book name that matches 1, adding ' closes the string, making the rest of the input part of the SQL statement. || 1=1 part uses the SQL OR operator to add a condition that is always true. This condition ensures that the query returns true for all records, bypassing the original condition that was supposed to restrict the results. Similarly, -- starts a comment in SQL, causing the database to ignore the rest of the query. This is useful to terminate any remaining part of the query that might cause syntax errors or unwanted conditions. To ensure proper spacing, + add a space after the comment, ensuring that the comment is properly terminated and there are no syntax issues.

From the console, we can see that clicking the search button makes an AJAX call to search_book.php.

network tab in console

Click to enlarge the image.

Let's use the payload directly on the PHP page to avoid unnecessary tweaking/validation from the client.  Let's visit the URL http://10.10.171.77/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1 with the standard payload Intro to PHP' OR 1=1, and you will see an error. 

testing injection on the API call

Now, URL encode the payload Intro to PHP' || 1=1 --+ using Cyber Chef and try to access the URL with an updated payload. We will get the following output dumping the complete information:

injection with correct payload

The payload works because URL encoding represents the special characters and SQL keywords in a way that bypasses the filtering mechanism. When the server decodes the URL-encoded input, it restores the special characters and keywords, allowing the SQL injection to execute successfully. Using URL encoding, attackers can craft payloads that bypass basic input filtering mechanisms designed to block SQL injection. This demonstrates the importance of using more robust defences, such as parameterised queries and prepared statements, which can prevent SQL injection attacks regardless of the input's encoding.