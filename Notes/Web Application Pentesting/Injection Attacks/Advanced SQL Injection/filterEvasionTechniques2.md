# No-Quote SQL Injection

No-Quote SQL injection techniques are used when the application filters single or double quotes or escapes.

### Using Numerical Values
One approach is to use numerical values or other data types that do not require quotes. For example, instead of injecting `' OR '1'='1`, an attacker can use `OR 1=1` in a context where quotes are not necessary. This technique can bypass filters that specifically look for an escape or strip out quotes, allowing the injection to proceed.

### Using SQL Comments
Another method involves using SQL comments to terminate the rest of the query. For instance, the input `admin'--` can be transformed into `admin--`, where the `--` signifies the start of a comment in SQL, effectively ignoring the remainder of the SQL statement. This can help bypass filters and prevent syntax errors.

### Using CONCAT() Function
Attackers can use SQL functions like `CONCAT()` to construct strings without quotes. For example, `CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)` constructs the string `admin`. The `CONCAT()` function and similar methods allow attackers to build strings without directly using quotes, making it harder for filters to detect and block the payload.

# No Spaces Allowed

When spaces are not allowed or are filtered out, various techniques can be used to bypass this restriction.

### Comments to Replace Spaces
One common method is to use SQL comments (`/**/`) to replace spaces. For example, instead of `SELECT * FROM users WHERE name = 'admin'`, an attacker can use `SELECT/**//*FROM/**/users/**/WHERE/**/name/**/='admin'`. SQL comments can replace spaces in the query, allowing the payload to bypass filters that remove or block spaces.

### Tab or Newline Characters
Another approach is using tab (`\t`) or newline (`\n`) characters as substitutes for spaces. Some filters might allow these characters, enabling the attacker to construct a query like `SELECT\t*\tFROM\tusers\tWHERE\tname\t=\t'admin'`. This technique can bypass filters that specifically look for spaces.

### Alternate Characters
One effective method is using alternative URL-encoded characters representing different types of whitespace, such as `%09` (horizontal tab), `%0A` (line feed), `%0C` (form feed), `%0D` (carriage return), and `%A0` (non-breaking space). These characters can replace spaces in the payload.

# Practical Example

In this scenario, we have an endpoint, `http://10.10.171.77/space/search_users.php?username=?` that returns user details based on the provided username. The developer has implemented filters to block common SQL injection keywords such as `OR`, `AND`, and spaces (`%20`) to protect against SQL injection attacks.

Here is the PHP filtering added by the developer:

```php
$special_chars = array(" ", "AND", "and" ,"or", "OR" , "UNION", "SELECT");
$username = str_replace($special_chars, '', $username);
$sql = "SELECT * FROM user WHERE username = '$username'";
```

If we use our standard payload `1%27%20||%201=1%20--+` on the endpoint, we can see that even through URL encoding, it is not working.

**Injection with incorrect payload**

The SQL query shows that the spaces are being omitted by code. To bypass these protections, we can use URL-encoded characters that represent different types of whitespace or line breaks, such as `%09` (horizontal tab), `%0A` (line feed). These characters can replace spaces and still be interpreted correctly by the SQL parser.

The original payload `1' OR 1=1 --` can be modified to use newline characters instead of spaces, resulting in the payload `1'%0A||%0A1=1%0A--%27+`. This payload constructs the same logical condition as `1' OR 1=1 --` but uses newline characters to bypass the space filter.

The SQL parser interprets the newline characters as spaces, transforming the payload into `1' OR 1=1 --`. Therefore, the query will be interpreted from `SELECT * FROM users WHERE username = '$username'` to `SELECT * FROM users WHERE username = '1' OR 1=1 --`.

Now, if we access the endpoint through an updated payload, we can view all the details.

**Injection with correct payload**

To summarise, it is important to understand that no single technique guarantees a bypass when dealing with filters or Web Application Firewalls (WAFs) designed to prevent SQL injection attacks. However, here are some tips and tricks that can be used to circumvent these protections. This table highlights various techniques that can be employed to try and bypass filters and WAFs:

| Scenario | Description | Example |
| --- | --- | --- |
| Keywords like SELECT are banned | SQL keywords can often be bypassed by changing their case or adding inline comments to break them up | `SElEcT * FrOm users` or `SE/**/LECT * FROM/**/users` |
| Spaces are banned | Using alternative whitespace characters or comments to replace spaces can help bypass filters. | `SELECT%0A*%0AFROM%0Ausers` or `SELECT/**/*/**/FROM/**/users` |
| Logical operators like AND, OR are banned | Using alternative logical operators or concatenation to bypass keyword filters. | `username = 'admin' && password = 'password'` or `username = 'admin'/**/||/**/1=1 --` |
| Common keywords like UNION, SELECT are banned | Using equivalent representations such as hexadecimal or Unicode encoding to bypass filters. | `SElEcT * FROM users WHERE username = CHAR(0x61,0x64,0x6D,0x69,0x6E)` |
| Specific keywords like OR, AND, SELECT, UNION are banned | Using obfuscation techniques to disguise SQL keywords by combining characters with string functions or comments. | `SElECT * FROM users WHERE username = CONCAT('a','d','m','i','n')` or `SElEcT/**/username/**/FROM/**/users` |

In real environments, the queries you apply and the visibility of filtered keywords are not directly possible. As a pentester, it is important to understand that SQL injection testing often involves a hit-and-trial approach, requiring patience and perseverance. Each environment can have unique filters and protections, making it necessary to adapt and try different techniques to find a successful injection vector.